*
* Shanghai
* (c) Copyright 1987 Activision
*
SCREEN EQU $8000

* TILE TABLE FORMAT:
*  ,U tile id
* 1,U pixel offset
* 3,U left
* 4,U right
* 5,U up
* 6,U down

 ORG 0
**************** base page
CSTAT  RMB 1
ARROW  RMB 1
FF91   RMB 1
FIND1  RMB 1
FIND2  RMB 1
BORDF  RMB 1 "in border" flag
FACE   RMB 5
TLPOS  RMB 1
TMOUT  RMB 1 number of timeouts
SCORES RMB 2 challenge match scores
NAMPTR RMB 2
NAMCNT RMB 1
TSCORE RMB 1 tournament player score
KEYON  RMB 1
CURMNU RMB 2 current menu
VMOVE  RMB 1 valid move flag
PLAYER RMB 1
TCOLOR RMB 1 tile mark color
TCOLP  RMB 2 tile mark pointer
TCOLC  RMB 1 tile mark counter
ROMSON RMB 1 "ROMs on" flag
MTIMER RMB 1 transient countdown timer
CTIMER RMB 1 challenge countdown timer
DRAGID RMB 1 selected dragon
OLDTIM RMB 1
TICKS  RMB 1
TOCKS  RMB 1
SECS   RMB 1
MINS   RMB 1
HOURS  RMB 1
STILE1 RMB 3 selected tile
STILE2 RMB 3
COUNT  RMB 1
MNUPTR RMB 2
CMASK  RMB 1
CURSXY RMB 2
SEED1  RMB 1
SEED2  RMB 1
LSW    RMB 1
RSW    RMB 1
CURSX  RMB 2
CURSY  RMB 1
TILEX  RMB 2
TILEY  RMB 1
TEMPX  RMB 2
TEMPY  RMB 2
HFLAG  RMB 1
ITEMX1 RMB 2
ITEMX2 RMB 2
ITEMY1 RMB 2
ITEMY2 RMB 2
TLIMIT RMB 1 time limit

 ORG $1000
**************** RAM storage
STACK  RMB 1
TILES  RMB 144*7
HISTRY RMB 144
SCBORD RMB 24*10 scoreboard
NAME   RMB 20
CACHE  RMB 6*10

 ORG $3000
START
 ORCC #$50
 LDS #STACK
 LBSR MINIT
 LBSR TASK0
 CLRA
 CLRB
 TFR B,DP
 STB $FF40
 STB KEYON
 STD MNUPTR
 STD FIND1
 STB BORDF
 STB HFLAG
 STB LSW
 STB RSW
 STB MTIMER
 STB ROMSON
 STB TLIMIT
 STB ARROW
 STB CSTAT

 CLR $71      hard reset
 CLR $FFD9    fast CPU
 STB $FFDF    64k mode
 
 LDA 200
 CMPA #123
 BEQ A@
 LBSR RGBSET
A@
 LBSR VINIT

 LBSR CLBORD clear scoreboard

*init clock
 CLR TICKS
 CLR SECS
 CLR MINS
 CLR HOURS
 LEAU IRQ,PCR
 STU $10D
 LDA $FF03
 ORA #3
 STA $FF03
 ANDCC #$EF start clock

* title page
 CLR DRAGID
 LBSR CLS
 LBSR BORDER
 LDA #9
 LDB #2
 LBSR CPOS
 LEAU TITLE1,PCR
 LBSR MSG
 LDA #5
 LDB #3
 LBSR CPOS
 LEAX 2*160,X
 LEAU TITLE2,PCR
 LBSR MSG

 LEAU TPMENU,PCR
 LBRA TMENU

MRGB
 LDA 200
 CMPA #123
 BEQ MAIN
 LBSR RGBSET
 BRA MAIN
MCMP
 LDA 200
 CMPA #123
 BEQ MAIN
 LBSR CMPSET

* main menu
MAIN
DM9
 LBSR CLS
 LDA #9
 LDB #5
 LBSR CPOS
 LEAU MNHEAD,PCR
 LBSR MSG
 LEAU MNMENU,PCR
 LBRA TMENU

* solitaire
MM1
 CLR TLIMIT
* begin again
MM2
 LBSR GDRAGN
* return to game
MM6
 TST COUNT no tiles?
 BEQ MM2 begin again
 LBSR CLS

 LBSR DRAGON
 LBSR UCOUNT
 TST TLIMIT
 LBGT CHGAME challenge game?
 LBLT TOGAME tournament game?

*game screen menu
 LEAU GMMENU,PCR
 LBSR DMENU
 LBSR CLTILE
GMLOOP
 LDB #1
 LBSR CURSOR
 LEAU GMMENU,PCR
 LBSR UMENU
 LDB #1
 LBSR BUTTON
 BEQ GMLOOP
 LBSR XMENU

*tile selected?
 LBSR SELECT
 TSTB
 BEQ GMLOOP
 LBSR MOVE
 BRA GMLOOP

*** menu bar options

*menu
GM1
 LBRA MAIN
*undo
GM2
 LBSR UNDO
 LBRA GMLOOP
*find
GM3
 LBSR FIND
 LBRA GMLOOP
*cancel
GM4
 LBSR CANCEL
 LBRA GMLOOP
*peek
GM5
 LBRA PEEK

**** process move
MOVE
 CLR VMOVE

* click on a non-free tile?
 LBSR FREE
 BNE NTFREE

* second click on second tile?
 CMPU STILE2
 LBEQ RMTILE

* second click on first tile?
 CMPU STILE1
 BNE C11T  no
 LDD FIND1 find in progress?
 LBEQ CANCEL if not, cancel
 LBRA RMTILE if so, remove

* first click on first tile?
C11T
 LDY STILE1
 LBEQ T1CLIK

* first click on second tile?
 LDY STILE2
 LBEQ T2CLIK
 RTS

* first click on first tile
T1CLIK
 LBSR CLICK
 STU STILE1
 STB STILE1+2
 LBSR HILITE
 RTS

NTFREE
 LBSR PING
 LBSR CANCEL
 LEAX NTFR1,PCR
 LEAY NTFR2,PCR
 LBSR UMSG
 RTS

NTFR1
 FCC "Tile is",0
NTFR2
 FCC "not free",0

* first click on second tile
T2CLIK

*check to see if tiles match
 LDY STILE1
 LBSR MATCH
 BNE NOMATC

*they match, go ahead and highlight
RMOKAY
 LBSR CLICK
 STU STILE2
 STB STILE2+2
 LBSR HILITE
 RTS

* remove the pair of tiles
RMTILE
 LDU STILE1
 LDB STILE1+2
 LBSR REMOVE   remove first tile
 LDU STILE2
 LDB STILE2+2
 LBSR REMOVE   remove second tile
 LBSR UCOUNT
 LBSR CLICK
 LBSR CLTILE
 LBSR VICTOR   victory dragon(?)
 INC VMOVE
 RTS

* The tiles don't match
NOMATC
 LBSR PING
 LBSR CANCEL cancel first selection
 LEAX NOMT1,PCR
 LEAY NOMT2,PCR
 LBSR UMSG
 RTS

* Undo
UNDO
 LDD STILE1 if move in progress
 LBNE CANCEL do "cancel" instead
 LDA COUNT
 CMPA #144
 LBEQ XUNDO
 LBSR TUNDO
 LBSR TUNDO
XUNDO
 RTS

*undo last tile removal
TUNDO
 LDX #HISTRY
 LDB COUNT
 CLRA
 LEAX D,X
 LDB ,X B is tile pos
 LDU #TILES
 LDA #7
 PSHS B
 DECB
 MUL
 LEAU D,U
 PULS B
* now U points to tile data
* B is tile pos
 COM ,U un-delete tile
 LBSR REFRES
 INC COUNT count it
 LBSR UCOUNT
 RTS

* Find
FIND
 LBSR CUROFF
 LBSR CANCL
 LDD FIND1
 BNE FCONT
* for i=0 to 142
A@
 LDA FIND1
 CMPA #142
 BHI Z@
* for j=i+1 to 143
 LDA FIND1
 INCA
 STA FIND2
B@
 LDA FIND2
 CMPA #143
 BHI Y@
* link to tile 1
 LDA FIND1
 INCA
 STA STILE1+2
 DECA
 LDB #7
 MUL
 LDU #TILES
 LEAU D,U
 STU STILE1
* link to tile 2
 LDA FIND2
 INCA
 STA STILE2+2
 DECA
 LDB #7
 MUL
 LDU #TILES
 LEAU D,U
 STU STILE2
 LBSR FREE 1st tile free?
 BNE N@
 LDU STILE1
 LBSR FREE 2nd tile free?
 BNE N@
 LDU STILE1 identical tiles?
 CMPU STILE2
 BEQ N@
 LDY STILE2
 LBSR MATCH tiles match?
 BNE N@
*found something!
 LDU STILE1
 LDB STILE1+2
 LBSR REFRES
 LDU STILE2
 LDB STILE2+2
 LBSR REFRES
 LBSR UCOUNT
 LBSR CURON
 RTS
* next j
FCONT
N@
 INC FIND2
 BRA B@
Y@
* next i
 INC FIND1
 BRA A@
*didn't find anything
Z@
 LBSR PING
 LBSR CANCEL
 LEAX NMM1,PCR "No more"
 LEAY NMM2,PCR " Moves"
 LBSR UMSG
 CLRA
 CLRB
 STD FIND1
 LBSR CURON
 RTS

NMM1
 FCC " No more",0
NMM2
 FCC "  moves",0

NOMT1
 FCC "Tile does",0
NOMT2
 FCC "not match",0

* Cancel
CANCEL
 CLRA
 CLRB
 STD FIND1 cancel find sequence
CANCL
 LDD STILE1
 BEQ Z@
 LDD STILE2
 BEQ A@
* de-highlight tile 2
 LDU STILE2
 LDB STILE2+2
 CLR STILE2
 CLR STILE2+1
 CLR STILE2+2
 LBSR REFRES
A@
* de-highlight tile 1
 LDU STILE1
 LDB STILE1+2
 CLR STILE1
 CLR STILE1+1
 CLR STILE1+2
 LBSR REFRES
Z@
 RTS

TOHEAD
 FCC "Tournament - Select time"
 FCC " limit",0

* Tournament menu
MM4
 LBSR CLS
 LDA #4
 LDB #5
 LBSR CPOS
 LEAU TOHEAD,PCR
 LBSR MSG
 LEAU TOMENU,PCR
 LBRA TMENU

TO1
 LDA #-5
 BRA Z@
TO2
 LDA #-10
Z@
 STA TLIMIT
 LBSR CUROFF
 LEAU TOMENU,PCR
 LBSR DMENU
 LBSR GETNAM
 CLR TSCORE
 LBRA MM2
TO3
 LBRA MAIN

*Tournament game screen menu
TOGAME
 LEAU TGMENU,PCR
 LBSR DMENU
 LBSR CLTILE

 LBSR UUTIME

 CLR TSCORE
 LDA #1
 STA PLAYER
 LDA TLIMIT
 STA CTIMER
 LBSR UTSCOR

TGLOOP
 TST CTIMER
 LBEQ ENTOUR
 LDB PLAYER
 LBSR CURSOR
 LEAU TGMENU,PCR
 LBSR UMENU
 LBSR UTIME update timer display
 LDB PLAYER
 LBSR BUTTON
 BEQ TGLOOP
 LBSR XMENU

*tile selected?
 LBSR SELECT
 TSTB
 BEQ TGLOOP
 LBSR MOVE
 TST VMOVE
 BEQ TGLOOP
* update tournament score
 INC TSCORE
 LBSR UTSCOR
 BRA TGLOOP

*** tournament turn is over
ENTOUR
 LBSR CANCEL
 LBSR CHIME  double chime
 LBSR CHIME
 LBSR POST   post score to scoreboard
 LBSR PTBORD display scoreboard
 LBEQ MAIN   tournament over
 LBRA MM2    continue tournament

*** tournament game menu bar options

*quit
TG1
 LBRA ENTOUR
*undo
TG2
 LBSR UNDO
 TST TSCORE
 LBEQ TGLOOP
 DEC TSCORE
 LBSR UTSCOR back up score
 LBRA TGLOOP
*cancel
TG3
 LBSR CANCEL
 LBRA TGLOOP

TITLE1
 FCC "Shanghai",0
TITLE2
 FCC "(c) Copyright 1987 Activision",0
MNHEAD
 FCC "Shanghai Main Menu:",0
DMHEAD
 FCC "Select a Dragon:",0

*challenge match game screen menu
CHGAME
 LEAU CGMENU,PCR
 LBSR DMENU
 LBSR CLTILE
 CLR TSCORE
 CLR SCORES
 CLR SCORES+1
 CLR TMOUT
 LBSR UUTIME
 LBSR UTSCOR
 LDA #1
 STA PLAYER
 LEAX PLAYR1,PCR
 LDY #0
 LBSR UMSG
 LDA TLIMIT
 STA CTIMER
CGLOOP
 TST CTIMER
 LBEQ ENTURN
 LDB PLAYER
 LBSR CURSOR
 LEAU CGMENU,PCR
 LBSR UMENU
 LBSR UTIME update timer display
 LDB PLAYER
 LBSR BUTTON
 BEQ CGLOOP
 LBSR XMENU

*tile selected?
 LBSR SELECT
 TSTB
 BEQ CGLOOP
 LBSR MOVE
 TST VMOVE
 BEQ CGLOOP
 BRA ENTU0

*** turn is over
ENTURN
* timed out
 LBSR CANCEL
 LBSR CHIME
 INC TMOUT
 LDA TMOUT
 CMPA #4
 LBEQ CHDONE
 BRA Z@
ENTU0
* player scored
 CLR TMOUT
 INC TSCORE
Z@
 TST COUNT check for no more tiles
 LBEQ CHDONE
 LDX #SCORES-1
 LDA PLAYER
 LEAX A,X
 LDB TSCORE
 STB ,X   put score away
 LBSR UTSCOR show score
 LBSR CUROFF
 LBSR DELAY
 LBSR CURON
* change to next player
 LDA PLAYER
 LDB #1
 LEAX PLAYR1,PCR
 LDY #0
 CMPA #1
 BNE A@
 LEAX PLAYR2,PCR
 INCB
A@
 STB PLAYER
 LBSR UMSG
 LDX #SCORES-1
 LDB PLAYER
 LEAX B,X
 LDA ,X
 STA TSCORE next players score
 LBSR UTSCOR
 LDA TLIMIT reset timer
 STA CTIMER
 LBRA CGLOOP

PLAYR1
 FCC "Player one",0
PLAYR2
 FCC "Player two",0

*** challenge game menu bar options

*quit
CG1
 LBRA CHDONE
*cancel
CG2
 LBSR CANCEL
 LBRA CGLOOP

* Challenge match done
CHDONE
 LBSR CHBORD
 LBRA MAIN

* tile select sound
*
CLICK
 PSHS D
 LBSR CLIK
 PULS D,PC

* Dragon menu
MM3
 LBSR CLS
 LDA #9
 LDB #2
 LBSR CPOS
 LEAU DMHEAD,PCR
 LBSR MSG
 LEAU DGMENU,PCR
 LBRA TMENU

DM1
 LDB #1
 BRA DMCOM
DM2
 LDB #2
 BRA DMCOM
DM3
 LDB #3
 BRA DMCOM
DM4
 LDB #4
 BRA DMCOM
DM5
 LDB #5
 BRA DMCOM
DM6
 LDB #6
 BRA DMCOM
DM7
 LDB #7
 BRA DMCOM
DM8
 LDB #8
DMCOM
 STB DRAGID
 LBRA DM9

PKHEAD
 FCC "Peek under tiles and forfeit"
 FCC " game?",0

* Peek menu
PEEK
 LBSR CLS
 LDA #2
 LDB #6
 LBSR CPOS
 LEAU PKHEAD,PCR
 LBSR MSG
 LEAU PKMENU,PCR
 LBRA TMENU

* No
PM2
 LBRA MM2
* Yes
PM1

* Peek game

 LBSR CLS
 LBSR DRAGON
 LBSR UCOUNT

*game screen menu
 LEAU PGMENU,PCR
 LBSR DMENU
 LBSR CLTILE
PGLOOP
 LDB #1
 LBSR CURSOR
 LEAU PGMENU,PCR
 LBSR UMENU
 LDB #1
 LBSR BUTTON
 BEQ PGLOOP
 LBSR XMENU

*tile selected?
 LBSR SELECT
 TSTB
 BEQ PGLOOP
 LBSR REMOVE
 LBSR UCOUNT
 LBSR CLICK
 BRA PGLOOP

*** peek game menu bar options

*quit
PG1
 LDA 200   check magic flag
 CMPA #123
 LBEQ MAIN
 CLR COUNT prevent cheating
 LBRA MAIN
*undo
PG2
 LDA COUNT
 CMPA #144
 LBEQ PGLOOP
 LBSR TUNDO
 LBRA PGLOOP

CHHEAD
 FCC "CHALLENGE MATCH - Select time"
 FCC " limit",0

* Challenge menu
MM5
 LBSR CLS
 LDA #2
 LDB #6
 LBSR CPOS
 LEAU CHHEAD,PCR
 LBSR MSG
 LEAU CHMENU,PCR
 LBRA TMENU

CH1
 LDA #10
 STA TLIMIT
 LBRA MM2
CH2
 LDA #20
 STA TLIMIT
 LBRA MM2
CH3
 LDA #30
 STA TLIMIT
 LBRA MM2
CH4
 LDA #60
 STA TLIMIT
 LBRA MM2
CH5
 LBRA MAIN

* Highlight tile
* U points to entry in tile table,
* B contains tile position (1-144)
HILITE
 PSHS D,X,Y,U
 LBSR REFRES
 PULS D,X,Y,U,PC

* Remove tile
* U points to entry in tile table,
* B contains tile position (1-144)
REMOVE
 DEC COUNT
 PSHS B       remember this move
 LDX #HISTRY  so we can undo it
 LDB COUNT    later if necessary
 CLRA
 LEAX D,X
 PULS B
 STB ,X     put into history list
 COM ,U     that tile is removed
 LBSR REFRES
 RTS

*CMP Color set
CMPSET
 LBSR VSYNC
 LDA #0     background black 0
 STA $FFB0
 LDA #37    border yellow    1
 STA $FFB1
 LDA #26    dark purple      2
 STA $FFB2
 LDA #21    orange/brown     3
 STA $FFB3
 LDA #20    green            4
 STA $FFB4
 LDA #7     dark red         5
 STA $FFB5
 LDA #12    blue             6
 STA $FFB6
 LDA #11    dark blue        7
 STA $FFB7
 LDA #38                     8
 STA $FFB8
 LDA #11    background dkblu 9
 STA $FFB9
 STA $FF9A
 LDA #32                     B
 STA $FFBB
 LDA #52                     C
 STA $FFBC
 LDA #63    blinking hilite  D
 STA $FFBD
 LDA #32    tile grey        E
 STA $FFBE
 LDA #63    tile white       F
 STA $FFBF
 RTS

*RGB Color set
RGBSET
 LBSR VSYNC
 LDA #0     black            0
 STA $FFB0
 LDA #55    edge yellow      1
 STA $FFB1
 LDA #40    dark purple      2
 STA $FFB2
 LDA #34    pumpkin orange   3
 STA $FFB3
 LDA #20    dark green       4
 STA $FFB4
 LDA #36    dark red         5
 STA $FFB5
 LDA #13    blue             6
 STA $FFB6
 LDA #12    dark blue        7
 STA $FFB7
 LDA #38    light orange     8
 STA $FFB8
 LDA #12    background dkblu 9
 STA $FFB9
 STA $FF9A
 LDA #56    tile light grey  B
 STA $FFBB
 LDA #62    tile pale yellow C
 STA $FFBC
 LDA #63    blinking hilite  D
 STA $FFBD
 LDA #56    tile dark grey   E
 STA $FFBE
 LDA #63    tile white       F
 STA $FFBF
XRGB
 RTS

* complete 16-color blank tile
BLANK
 FDB $EEEE,$EEEE,$EEEE,$EEEE,$EEEE,$E000
 FDB $CCCC,$CCCC,$CCCC,$CCCC,$CCCC,$E000
 FDB $CCFF,$FFFF,$FFFF,$FFFF,$FFCC,$E000
 FDB $CCFF,$FFFF,$FFFF,$FFFF,$FFFC,$E000
 FDB $CCFF,$FFFF,$FFFF,$FFFF,$FFFC,$E000
 FDB $CCFF,$FFFF,$FFFF,$FFFF,$FFFC,$E000
 FDB $CCFF,$FFFF,$FFFF,$FFFF,$FFFC,$E000
 FDB $CCFF,$FFFF,$FFFF,$FFFF,$FFFC,$E000
 FDB $CCFF,$FFFF,$FFFF,$FFFF,$FFFC,$E000
 FDB $CCFF,$FFFF,$FFFF,$FFFF,$FFFC,$E000
 FDB $CCFF,$FFFF,$FFFF,$FFFF,$FFFC,$E000
 FDB $CCFF,$FFFF,$FFFF,$FFFF,$FFFC,$E000
 FDB $CCFF,$FFFF,$FFFF,$FFFF,$FFFC,$E000
 FDB $CCFF,$FFFF,$FFFF,$FFFF,$FFFC,$E000
 FDB $CCFF,$FFFF,$FFFF,$FFFF,$FFFC,$E000
 FDB $CCFF,$FFFF,$FFFF,$FFFF,$FFFC,$E000
 FDB $CCFF,$FFFF,$FFFF,$FFFF,$FFFC,$E000
 FDB $CCFF,$FFFF,$FFFF,$FFFF,$FFFC,$E000
 FDB $CCFF,$FFFF,$FFFF,$FFFF,$FFFC,$E000
 FDB $CCFF,$FFFF,$FFFF,$FFFF,$FFFC,$E000
 FDB $CCFF,$FFFF,$FFFF,$FFFF,$FFFC,$E000
 FDB $CCFF,$FFFF,$FFFF,$FFFF,$FFFC,$E000
 FDB $CCCC,$CCCC,$CCCC,$CCCC,$CCCC,$E000
 FDB $CCCC,$CCCC,$CCCC,$CCCC,$CCCC,$E000
BLANKH
 FDB $EEEE,$EEEE,$EEEE,$EEEE,$EEEE,$E000
 FDB $DDDD,$DDDD,$DDDD,$DDDD,$DDDD,$E000
 FDB $DDDD,$DDDD,$DDDD,$DDDD,$DDDD,$E000
 FDB $DDDD,$DDDD,$DDDD,$DDDD,$DDDD,$E000
 FDB $DDDD,$DDDD,$DDDD,$DDDD,$DDDD,$E000
 FDB $DDDD,$DDDD,$DDDD,$DDDD,$DDDD,$E000
 FDB $DDDD,$DDDD,$DDDD,$DDDD,$DDDD,$E000
 FDB $DDDD,$DDDD,$DDDD,$DDDD,$DDDD,$E000
 FDB $DDDD,$DDDD,$DDDD,$DDDD,$DDDD,$E000
 FDB $DDDD,$DDDD,$DDDD,$DDDD,$DDDD,$E000
 FDB $DDDD,$DDDD,$DDDD,$DDDD,$DDDD,$E000
 FDB $DDDD,$DDDD,$DDDD,$DDDD,$DDDD,$E000
 FDB $DDDD,$DDDD,$DDDD,$DDDD,$DDDD,$E000
 FDB $DDDD,$DDDD,$DDDD,$DDDD,$DDDD,$E000
 FDB $DDDD,$DDDD,$DDDD,$DDDD,$DDDD,$E000
 FDB $DDDD,$DDDD,$DDDD,$DDDD,$DDDD,$E000
 FDB $DDDD,$DDDD,$DDDD,$DDDD,$DDDD,$E000
 FDB $DDDD,$DDDD,$DDDD,$DDDD,$DDDD,$E000
 FDB $DDDD,$DDDD,$DDDD,$DDDD,$DDDD,$E000
 FDB $DDDD,$DDDD,$DDDD,$DDDD,$DDDD,$E000
 FDB $DDDD,$DDDD,$DDDD,$DDDD,$DDDD,$E000
 FDB $DDDD,$DDDD,$DDDD,$DDDD,$DDDD,$E000
 FDB $DDDD,$DDDD,$DDDD,$DDDD,$DDDD,$E000
 FDB $DDDD,$DDDD,$DDDD,$DDDD,$DDDD,$E000

*Clear screen
CLS
 CLR ARROW
 CLR CSTAT
 CLR MTIMER
CLSX
 LDX #$7D00
 LDD #$9999
 LDU #SCREEN
CLS0
 STD ,U++
 STD ,U++
 STD ,U++
 STD ,U++
 STD ,U++
 STD ,U++
 STD ,U++
 STD ,U++
 STD ,U++
 STD ,U++
 STD ,U++
 STD ,U++
 STD ,U++
 STD ,U++
 STD ,U++
 STD ,U++
 LEAX -32,X
 BNE CLS0
 RTS

*Init video
VINIT
*LDB #$0C
 LDB #$4C  mmu enabled
 STB $FF90 initialization register
 LDB #$80
 STB $FF98 video mode register
*LDB #$1E 192 lpf
*LDB #$7E 225 lpf
 LDB #$3E 200 lpf
 STB $FF99 video resolution register
 CLR $FF9F horiz scroll
*set screen location
*TST FLAG
*BEQ TR0
* task one, so change to
* task one screen
*LDD #$F000
*BRA SCLOC0
* task zero, so change to
* task zero screen
TR0
 LDD #$C000

SCLOC0
 STA $FF9D
 STB $FF9E
 RTS

* Mark tile
*
* X -> pixel offset of tile
* B = tile id
MKTILE
 PSHS B,X,U
 PSHS B
 LBSR GCOLOR get mark color
 LSRB
 LSRB
 LSRB
 LSRB
 ANDB #$0F
 DECB       B = tile type
 LEAU MKTBL,PCR
* now U -> mark table
 LSLB
 LEAU B,U
 LDD ,U
 LEAU D,U
* now U -> tile marks for that type
 PULS B
 ANDB #$0F
 DECB
 LDA #3*20
 MUL
 LEAU D,U
* now U -> tile marks for specific tile
 TFR X,D
 PSHS B
 LSRA
 RORB
 TFR D,X
 LBSR FUDGE point to correct byte
 LEAX 160,X
 LEAX 160,X down a couple rows
 PULS B
 ANDB #1
 LDA #$FF
 MUL
 COMB
 INCB over one column
 LDA #20
 PSHS A
MKTL
 DEC ,S
 BLT XMKTL
* X -> screen, U -> mark row
 PSHS X

 LBSR TROW
 LEAU 1,U
 LEAX 4,X
 LBSR TROW
 LEAU 1,U
 LEAX 4,X
 LBSR TROW
 LEAU 1,U
 LEAX 4,X

 PULS X
 LEAX 160,X
 LBSR NCOLOR get next color
 BRA MKTL
XMKTL
 PULS A
 PULS B,X,U
 RTS

* Mark tile row
*
* U points to 1 byte of mark data
* X points to screen position
TROW
 PSHS X,U,B
 LDA ,U
 PSHS A
TROW0
 LDA ,S
 BEQ TROW2
 INCB
 LSLA
 STA ,S
 BCC TROW0
 TFR X,Y
 TFR B,A
 LSRA
 LEAY A,Y
 TFR B,A
 ANDA #1
 BEQ TROW1
 LDA ,Y
 ANDA #$F0
 STA ,Y
 LDA TCOLOR
 ANDA #$0F
 ORA ,Y
 STA ,Y
 BRA TROW0
TROW1
 LDA ,Y
 ANDA #$0F
 STA ,Y
 LDA TCOLOR
 ANDA #$F0
 ORA ,Y
 STA ,Y
 BRA TROW0
TROW2
 PULS A
 PULS X,U,B
 RTS

MKTBL
 FDB DRA1-*
 FDB WIN1-*
 FDB SEA1-*
 FDB FLO1-*
 FDB DOT1-*
 FDB CRK1-*
 FDB BAM1-*

* Draw blank tile
*
* X -> pixel offset of tile
* U -> tile data

TILE
 PSHS X,U
*put 21 pixels (11 bytes) across, 24 bytes down
 TFR X,D
 ANDB #1
 BNE ODD

*on even pixel boundary
 TFR X,D
 LSRA
 RORB
 TFR D,X
 LBSR FUDGE
 LDA #24
 PSHS A

LY
 DEC ,S
 BLT XLY
 TFR X,Y

* 11 bytes across
 LDD ,U++
 STD ,Y++
 LDD ,U++
 STD ,Y++
 LDD ,U++
 STD ,Y++
 LDD ,U++
 STD ,Y++
 LDD ,U++
 STD ,Y++
 LDA ,Y
 ANDA #$0F
 ORA ,U+
 STA ,Y+
 LEAU 1,U
 LEAX 160,X go to next screen row
 BRA LY
XLY
 PULS A
 PULS X,U
 RTS

ODD
*on odd pixel boundary
 TFR X,D
 LSRA
 RORB
 TFR D,X
 LBSR FUDGE
 LDA #24
 PSHS A

OLY
 DEC ,S
 LBLT XOLY
 TFR X,Y

* 11 bytes across
 LDA ,Y      pixel 1
 ANDA #$F0
 STA ,Y
 LDA ,U
 ANDA #$F0
 LSRA
 LSRA
 LSRA
 LSRA
 ORA ,Y
 STA ,Y+

 LBSR TWOPXL 2 and 3
 LBSR TWOPXL 4 and 5
 LBSR TWOPXL 6 and 7
 LBSR TWOPXL 8 and 9
 LBSR TWOPXL 10 and 11
 LBSR TWOPXL 12 and 13
 LBSR TWOPXL 14 and 15
 LBSR TWOPXL 16 and 17
 LBSR TWOPXL 18 and 19
 LBSR TWOPXL 20 and 21

 LEAU 2,U

 LEAX 160,X go to next screen row
 LBRA OLY
XOLY
 PULS A
 PULS X,U
 RTS


TWOPXL
 LDA ,U+
 LDB ,U
 ANDB #$F0
 LSLB
 ROLA
 LSLB
 ROLA
 LSLB
 ROLA
 LSLB
 ROLA
 STA ,Y+
 RTS

*Draw a dragon
*
DRAGON
 LEAX BASES,PCR
A@
 LDA ,X+
 BEQ Z@
 DECA
 LDB #7
 MUL
 LDU #TILES
 LEAU D,U
 LBSR TPILE
 BRA A@
Z@
 LBSR DO144
 RTS

*translate tile coordinate system
FUDGE
 LEAX 8*160,X room for menu
 LEAX 2,X right justify
 LEAX SCREEN,X screen offset
 RTS

XAXIS1 EQU $15A
YAXIS1 EQU $15B
XAXIS2 EQU $15C
YAXIS2 EQU $15D

* Draw cursor
*
* B = joystick (1=right, 2=left)
*
CURSOR
 PSHS B

 INC ROMSON  tell IRQ that ROMs on
 STA $FFDE   turn on ROMs
 LBSR TASK1  force task 1
 JSR [$A00A] get joystick values
 CLR ROMSON  tell IRQ that ROMs off
 STA $FFDF   turn off ROMs
 LBSR TASK0

 PULS B      got left
 CMPB #1     want right?
 BEQ CUR0
 LDD XAXIS2
 STD XAXIS1  get left

CUR0
 LDA XAXIS1
 CMPA #62
 BLS CUR1
 LDA #62 don't let arrow wrap-around
CUR1
 LDB YAXIS1
 CMPB #62
 BLS CUR2
 LDB #62
CUR2
 CMPD CURSXY
 BEQ XCURS

 PSHS D save new xy

* erase old cursor
 TST ARROW
 BEQ A@
 LBSR CUROFF
A@
 LDA #1
 STA ARROW

* draw new cursor
 PULS D       get new xy back
 STD CURSXY
 LBSR CURON  draw new cursor

XCURS
 RTS
 
* Random number generator
* Entry: B - upper limit
*           (lower limit = 1)
* Exit: B - random number
*
* Routine donated by Jim Issel
*
RND PSHS B
RLP1 LDA SEED1
 LDB #5
 MUL
 PSHS D
 LDA SEED2
 LDB #8
 MUL
 ADDD ,S++
 EXG A,B
 CLRB
 PSHS D
 LDA SEED2
 LDB #5
 MUL
 ADDD ,S++
 ADDD #$3871
 STD SEED1
 CMPA ,S
 BHI RLP1
 TSTA
 BEQ RLP1
 PULS B
 EXG A,B
 CLRA
 RTS

* Generate a random dragon
RDRAGN
* transfer tile data to RAM
 LEAX DDATA,PCR
 LEAY TABLE,PCR
 LDU #TILES
 LDA #144
 STA COUNT
 PSHS A
RDRL
 DEC ,S
 LDA ,S
 CMPA #$FF
 BEQ XRDRL

 LDA ,X+
 STA ,U+  tile id
 LDD ,Y++
 STD ,U++ tile voffset
 LDD ,Y++
 STD ,U++ left, right
 LDD ,Y++
 STD ,U++ up, down
 BRA RDRL
XRDRL
* Pass through tile id's
 LDA #144
 STA ,S
RDRL2
 DEC ,S
 LDA ,S
 CMPA #$FF
 BEQ XRDRL2
* Pick a random place to swap with
 LDB #144
 LBSR RND
 DECB
 LDA #7
 MUL
 LDX #TILES
 TFR X,Y
 LEAX D,X
 LDB ,S
 LDA #7
 MUL
 LEAY D,Y
* Do the swap
 LDA ,X
 LDB ,Y
 STA ,Y
 STB ,X
 BRA RDRL2

XRDRL2
 PULS A
 RTS

* Generate a dragon
* 
GDRAGN
 LDB DRAGID
 TSTB
 LBEQ RDRAGN
* transfer tile data to RAM
 LEAX DDATA,PCR
 LDA #144
 DECB
 MUL
 LEAX D,X
 LEAY TABLE,PCR
 LDU #TILES
 LDA #144
 STA COUNT
 PSHS A
GDRL
 DEC ,S
 LDA ,S
 CMPA #$FF
 BEQ XGDRL
 LDA ,X+
 STA ,U+  tile id
 LDD ,Y++
 STD ,U++ tile voffset
 LDD ,Y++
 STD ,U++ left, right
 LDD ,Y++
 STD ,U++ up, down
 BRA GDRL
XGDRL
 PULS A
 RTS

* Put message on screen
* U points to message
* Message terminated by zero byte
* X points to screen location
MSG
 LDB ,U+
 BEQ XMSG
 PSHS U
 LBSR PUT
 PULS U
 BRA MSG
XMSG
 CLR HFLAG
 RTS

* Put character on screen
* X points to screen
* B has character in it
PUT
 PSHS D,X,Y,U
 CMPB #'a    lower case?
 BLO PUTUC
 SUBB #'a-'A convert to upper case
PUTUC
 SUBB #' 
 BLT PUT9
 LEAU FONT,PCR
 LDA #8
 MUL
 LEAU D,U
 LDA #8
 PSHS A

PUT0
 DEC ,S
 BLT PUT1
 LDA ,U+
 LBSR CROW
 LEAX 160,X
 BRA PUT0

PUT1
 PULS A

PUT9
 PULS D,X,Y,U
 LEAX 4,X    *** was 3 ***
 RTS

* put character row on screen
* X points to screen
* A is row bits
CROW
 PSHS A
 LDA #$FF   default color is white
 STA CMASK
 TST BORDF  in border?
 BEQ A@
 LDA #$11   yellow
 STA CMASK
A@
 TST HFLAG
 BEQ CROWH
 LDA #$DD   highlight color white/grey
 STA CMASK
CROWH
 PULS A
 LDB #$99   background color
 STB ,X
 STB 1,X
 STB 2,X
 STB 3,X
 LDB #$FF
 PSHS A
CROW0
 LDA ,S
 BEQ CROW2
 INCB
 LSLA
 STA ,S
 BCC CROW0
 TFR X,Y
 TFR B,A
 LSRA
 LEAY A,Y
 TFR B,A
 ANDA #1
 BEQ CROW1

*put into right nibble
 LDA ,Y
 ANDA #$F0
 PSHS A
 LDA CMASK
 ANDA #$0F
 ORA ,S+
 STA ,Y
 BRA CROW0
CROW1
* left nibble
 LDA ,Y
 ANDA #$0F
 PSHS A
 LDA CMASK
 ANDA #$F0
 ORA ,S+
 STA ,Y
 BRA CROW0
CROW2
 PULS A
 RTS

* Button
*
* B = 2 (left) or 1 (right)
* returns 1 in B if button on
*
BUTTON
 LDA #$7F
 STA $FF02
*assume left for now
 LDU #LSW   LSW
 LDA #2     left mask
 CMPB #1
 BNE BUT0
 LEAU 1,U   RSW
 LDA #1     right mask
BUT0
 ANDA $FF00
 BEQ BON

*button was off
 CLR ,U
 BRA BRETOF

*button was on
BON
 TST ,U     previous state?
 BNE BRETOF

*on, previously off
 INC ,U
 LDB #1
 RTS

BRETOF
 CLRB
 RTS

* convert voffset to x,y
* U -> X:Y
* D = voffset
VXY
 PSHS D,Y
 TFR D,Y
 CLR 2,U
 LSRA
 RORB
VXYL
 SUBD #160
 BLT XXYL
 INC 2,U
 LEAY -320,Y
 BRA VXYL
XXYL
 STY ,U
 PULS D,Y
 RTS

* Select tile to remove
*
* returns with B = tile pos
* if tile selected, B = 0 if tile not
* selected,
* and U points to entry in tile table
*
SELECT
* forget this
*LBSR CXYV
*LDU #CURSX
*LBSR VXY

*try this instead
 LDA CURSXY
 LDB #5
 MUL
 STD CURSX
 LDA CURSXY+1
 LDB #3
 MUL
 STB CURSY

 LDA #144
 PSHS A
SLL
 DEC ,S
 LDA ,S
 LDB #7
 MUL
 LDX #TILES
 LEAX D,X
 TST ,X     exists?
 BLE XSLL   ** BEQ
 TST 5,X    visible?
 BEQ SLLG

 LDA 5,X    check tile above
 DECA
 LDB #7
 LDU #TILES
 MUL
 LEAU D,U
 TST ,U     exists?
 BGT XSLL   not visible ** BNE

SLLG
 CLRA
 LDB ,S
 INCB
 TFR D,Y    remember tile position
 LDD 1,X    convert voffset
 EXG D,X
 LBSR FUDGE
 EXG D,X
 SUBD #SCREEN

 LDU #TILEX
 LBSR VXY

 LDA CURSY  above tile?
 CMPA TILEY
 BLO XSLL

 LDA TILEY  below tile?
 ADDA #23
 CMPA CURSY
 BLO XSLL

 LDD CURSX  to left of tile?
 CMPD TILEX
 BLO XSLL

 LDD TILEX  to right of tile?
 ADDD #20
 CMPD CURSX
 BLO XSLL

 TFR X,U    tile is selected!
 PULS B
 INCB
 RTS
XSLL
 TST ,S
 BNE SLL
 PULS B
 CLRB
 RTS

CXYV
 LDD CURSXY
 PSHS A
 LDX #0 (SCREEN)
 LDA #3
 MUL
*LDA #320  this won't work
 MUL
 LEAX D,X
 LDB ,S+
 LDA #5
 MUL
 LSRA
 RORB
 LEAX D,X
 TFR X,D
 RTS

CURON
 PSHS D,X,Y,U
 TST CSTAT
 LBNE XARW
 LDA #1
 STA CSTAT
 LBSR GETCP
 PSHS B,X
*suck up memory at cursor
 LDY #CACHE
 LDA #10
 PSHS A
A@
 DEC ,S
 BLT Z@
 LDD ,X++
 STD ,Y++
 LDD ,X++
 STD ,Y++
 LDD ,X++
 STD ,Y++
 LEAX 160-6,X
 BRA A@
Z@
 PULS A
 PULS B,X
*put cursor onto screen
 ANDB #1
 LBEQ EVARW

*odd arrow
 LDA ,X 1st row
 ORA #$0F
 STA ,X
 LDD #$FFFF
 STD 1,X
 STA 3,X
 LEAX 160,X

 LDA ,X 2nd row
 ORA #$0F
 STA ,X
 CLR 1,X
 CLR 2,X
 LDA 3,X
 ORA #$F0
 STA 3,X
 LEAX 160,X

 LDA ,X 3rd row
 ORA #$0F
 STA ,X
 CLR 1,X
 LDA #$0F
 STA 2,X
 LEAX 160,X

 LDA ,X 4th row
 ORA #$0F
 STA ,X
 CLR 1,X
 CLR 2,X
 LDA 3,X
 ORA #$F0
 STA 3,X
 LEAX 160,X

 LDA ,X 5th row
 ORA #$0F
 STA ,X
 LDA #$0F
 STA 1,X
 CLR 2,X
 STA 3,X
 LEAX 160,X

 LDA ,X 6th row
 ORA #$0F
 STA ,X
 LDA 1,X
 ORA #$F0
 STA 1,X
 LDA #$F0
 STA 2,X
 CLR 3,X
 LDA 4,X
 ORA #$F0
 STA 4,X
 LEAX 160,X

 LDA ,X 7th row
 ORA #$0F
 STA ,X
 LDA 2,X
 ORA #$0F
 STA 2,X
 CLR 3,X
 LDA #$0F
 STA 4,X
 LEAX 160,X

 LDA #$F0 8th row
 STA 3,X
 CLR 4,X
 LDA 5,X
 ORA #$F0
 STA 5,X
 LEAX 160,X

 LDA 3,X 9th row
 ORA #$0F
 STA 3,X
 LDA #$0F
 STA 4,X
 LEAX 160,X

 LDA 4,X
 ORA #$F0
 STA 4,X

 LBRA XARW

EVARW

*even arrow
 LDD #$FFFF 1st row
 STD ,X
 STA 2,X
 LDA 3,X
 ORA #$F0
 STA 3,X
 LEAX 160,X

 LDD #$F00F 2nd row
 STA ,X
 CLR 1,X
 STB 2,X
 LEAX 160,X

 STA ,X 3rd row
 CLR 1,X
 LDA 2,X
 ORA #$F0
 STA 2,X
 LEAX 160,X

 LDD #$F00F 4th row
 STA ,X
 CLR 1,X
 STB 2,X
 LEAX 160,X

 STA ,X 5th row
 STA 1,X
 CLR 2,X
 LDA 3,X
 ORA #$F0
 STA 3,X
 LEAX 160,X

 LDD #$FF0F 6th row
 STA ,X
 CLR 2,X
 STB 3,X
 LDA 1,X
 ORA #$0F
 STA 1,X
 LEAX 160,X

 LDA #$F0 7th row
 STA 2,X
 LDA ,X
 ORA #$F0
 STA ,X
 CLR 3,X
 LDA 4,X
 ORA #$F0
 STA 4,X
 LEAX 160,X

 LDA 2,X 8th row
 ORA #$0F
 STA 2,X
 CLR 3,X
 LDA #$0F
 STA 4,X
 LEAX 160,X

 LDA #$F0 9th row
 STA 3,X
 LDA 4,X
 ORA #$F0
 STA 4,X
 LEAX 160,X

 LDA 3,X 10th row
 ORA #$0F
 STA 3,X

XARW
 PULS D,X,Y,U
 RTS

* 
CUROFF
 PSHS D,X,Y,U
 TST CSTAT
 BEQ X@
 CLR CSTAT
 LBSR GETCP
*put back memory
 LDY #CACHE
 LDA #10
 PSHS A
A@
 DEC ,S
 BLT Z@
 LDD ,Y++
 STD ,X++
 LDD ,Y++
 STD ,X++
 LDD ,Y++
 STD ,X++
 LEAX 160-6,X
 BRA A@
Z@
 PULS A
X@
 PULS D,X,Y,U
 RTS

*get cursor byte pointer
GETCP
 LDD CURSXY
 PSHS A
 LDX #SCREEN
 LDA #3
 MUL
 LDA #160
 MUL
 LEAX D,X
 LDB ,S
 LDA #5
 MUL
 LSRA
 RORB
 LEAX D,X
*x is now byte pointer
 PULS B
 RTS


* PRINT NUMBER ROUTINE
* D = NUMBER
* X = voffset
*
PRTNUM PSHS  D,X,Y,U
       LBSR  NMOUT
       PULS  D,X,Y,U,PC

* Display number
*   B = number
*   X = voffset
*
NMOUT
 PSHS B
 LDY #0 zero suppress flag
* FIRST DIGIT
 LDA #'0
 LDB ,S
DIG1A
 SUBB #100
 BCS XDIG1
 STB ,S
 INCA
 BRA DIG1A
XDIG1
 CMPA #'0 zero suppress
 BEQ DIG2
 EXG B,A
 LBSR PUT print 1st digit
 EXG B,A
 LEAY 1,Y
* SECOND DIGIT
DIG2
 LDA #'0
 LDB ,S
DIG2A
 SUBB #10
 BLT XDIG2
 STB ,S
 INCA
 BRA DIG2A
XDIG2
 CMPY #0 previous digit nonzero?
 BNE DIG2B if so, don't suppress
 CMPA #'0 zero suppress
 BEQ DIG3
DIG2B
 EXG B,A
 LBSR PUT print 2nd digit
 EXG B,A
 LEAY 1,Y
* THIRD DIGIT
DIG3
 LDA #'0
 ADDA ,S
 EXG B,A
 LBSR PUT print 3rd digit
 EXG B,A
 LEAY 1,Y
* Y is 3, do nothing
* Y is 2, print space
* Y is 1, print 2 spaces
 TFR Y,D
 CMPB #3
 BEQ XDIGN
 PSHS B
 LDB #' 
 LBSR PUT
 PULS B
 CMPB #1
 BNE XDIGN
 PSHS B
 LDB #' 
 LBSR PUT
 PULS B

XDIGN
 PULS B
 RTS

* Update tile count display
UCOUNT
 PSHS D,X,Y,U
 LDA #2
 LDB #19
 LBSR CPOS
 LEAX 4*160,X
 LEAU UTMSG,PCR
 LBSR MSG
 LDA #3
 LDB #20
 LBSR CPOS
 LEAX 5*160,X
 LDB COUNT
 CLRA
 LBSR PRTNUM
 PULS D,X,Y,U,PC

UTMSG
 FCC "Tiles",0

IRQ
 LDA $FF02 clear interrupt
 STA $FFDF turn off ROMs
 CLRA
 STA $FF91 set task 0
 INC TICKS
 INC TOCKS

* flash highlight color
 LDA TOCKS
 ANDA #8
 BEQ IRQH0

IRQH1
 LDA $FFBF
 STA $FFBD
 BRA IRQ0

IRQH0
 LDA $FFBB
 STA $FFBD

IRQ0
 LDA TICKS
 CMPA #60
 BLT XIRQ

* one second
 TST CTIMER
 BLE A@
 DEC CTIMER update challenge timer
A@
 CLR TICKS
 INC SECS
 LDA SECS
 CMPA #60
 BLT XIRQ

* one minute
 TST CTIMER
 BGE B@
 INC CTIMER update tournament timer
B@
 CLR SECS
 INC MINS
 LDA MINS
 CMPA #60
 BLT XIRQ

* one hour
 CLR MINS
 INC HOURS
 LDA HOURS
 CMPA #60
 BLT XIRQ

* one day
 CLR HOURS
 CLR MINS
 CLR SECS
 CLR TICKS

XIRQ
* take care of message area
 TST MTIMER
 BEQ IRQF
 DEC MTIMER  time to clear it?
 LDA MTIMER
 BNE IRQF
 LBSR CLMSG  clear it
IRQF
 TST ROMSON  does foreground want ROMs
 BEQ XXIRQ   on?  if so, turn em on
 STA $FFDE
XXIRQ
 LDA FF91
 STA $FF91
 RTI

* Display two digits
*   B = number
*   X = voffset
*   Y = zero supress
*         0: don't
*         1: do supress
*
NM2OUT
 PSHS B

* FIRST DIGIT
D2G2
 LDA #'0
 LDB ,S
D2G2A
 SUBB #10
 BLT X2IG2
 STB ,S
 INCA
 BRA D2G2A
X2IG2
 CMPY #0 wants suppression?
 BEQ D2G2B no
 CMPA #'0
 BEQ D2G3 zero suppress
D2G2B
 EXG B,A
 LBSR PUT print 1st digit
 EXG B,A
* SECOND DIGIT
D2G3
 LDA #'0
 ADDA ,S
 EXG B,A
 LBSR PUT print 2nd digit
 EXG B,A

X2IGN
 PULS B
 RTS

* Set up time display
*
UUTIME
 PSHS D,X,Y,U
 LDA #2
 LDB #5
 LBSR CPOS
 LEAX -4*160+2,X
 TST TLIMIT
 BEQ Z@
 LEAU TSECS,PCR
 TST TLIMIT
 BGT A@
 LEAU TMINS,PCR
A@
 LBSR MSG    update time heading
 LDA #255
 STA OLDTIM  force time update
 CLR HOURS
 CLR MINS
 CLR SECS
 CLR TICKS
 LBSR UTIME  update time value
Z@
 PULS D,X,Y,U,PC

TMINS
 FCC "Mins",0
TSECS
 FCC "Secs",0

* Update time display
*
UTIME
 PSHS D,X,Y,U
 LDB CTIMER
 CMPB OLDTIM
 BEQ XUTIME
 STB OLDTIM
 LBSR CUROFF
 LDA #3 column
 LDB #6 row
 LBSR CPOS
 LEAX -3*160+2,X
 LDY #0
 LDB CTIMER
 BGE C@
 NEGB
C@
 LBSR NM2OUT
 LBSR CURON
XUTIME
 PULS D,X,Y,U,PC

*put something in the message area
* X -> message line 1
* Y -> message line 2 (0 if none)
*
UMSG
 LDA #240   set timer for message area
 STA MTIMER = 4 seconds
 PSHS Y
 PSHS X

 LBSR CLMSG  clear message area

 LDA #30     message first line
 LDB #5
 LBSR CPOS
 LEAX -160*4,X
 LDU ,S++
 LBSR MSG

 LDA #30     message second line
 LDB #6
 LBSR CPOS
 LEAX -160*4,X
 LDU ,S++
 PSHS U
 PULS D
 BEQ XUMSG   not a second line
 LBSR MSG

XUMSG
 LDA #240
 STA MTIMER
 RTS

* clear message area
CLMSG
 LBSR CUROFF
 LDA #30
 LDB #5
 LBSR CPOS
 LEAX -160*4,X
 LBSR CLAREA
 LDA #30
 LDB #6
 LBSR CPOS
 LEAX -160*4,X
 LBSR CLAREA
 LBSR CURON
 RTS

* clear one line of message area
* X -> message area line
*
CLAREA
 LDA #8
 PSHS A
 LDD #$9999
CLAL
 DEC ,S
 BLT XCLAL
 STD ,X++
 STD ,X++
 STD ,X++
 STD ,X++
 STD ,X++
 STD ,X++
 STD ,X++
 STD ,X++
 STD ,X++
 STD ,X++
 STD ,X++
 STD ,X++
 STD ,X++
 STD ,X++
 STD ,X++
 STD ,X++
 STD ,X++
 STD ,X++
 STD ,X++
 STD ,X++
 LEAX 160-40,X
 BRA CLAL

XCLAL
 PULS A
 RTS

* check if tile is free
* U -> tile in tile table
*
FREE
 PSHS B
 PSHS U

*check tile existence
 TST ,U
 BLE NFREE

*check above tile
 LDB 5,U
 BEQ C@
 LDA #7
 DECB
 MUL
 LDU #TILES
 LEAU D,U
 TST ,U
 BGT NFREE
C@
*check left tile
 LDU ,S
 LDB 3,U
 BEQ YFREE
 LDA #7
 DECB
 MUL
 LDU #TILES
 LEAU D,U
 TST ,U
 BLE YFREE
*check right tile
 LDU ,S
 LDB 4,U
 BEQ YFREE
 LDA #7
 DECB
 MUL
 LDU #TILES
 LEAU D,U
 TST ,U
 BLE YFREE

NFREE
*not free
 PULS U
 PULS B
 LDA #1
 TSTA
 RTS

YFREE
*yes free
 PULS U
 PULS B
 CLRA
 TSTA
 RTS

* get tile mark color
* B is tile id
GCOLOR
 PSHS X,Y,U,A
 PSHS B
 LEAX COTBL,PCR
 CMPB #DRA+2 red dragon
 BEQ RDDRA
 CMPB #DRA+3 green dragon
 BEQ GRDRA
 CMPB #BAM+1 one bam
 BEQ BRDRA
 ANDB #$F0
 CMPB #SEA
 BEQ SEASON
 LSRB
 LSRB
 LSRB
 LSRB
 DECB
 LDA #4
 MUL
 LEAX D,X
GCCONT
 STX TCOLP
 LDA ,X
 STA TCOLC
 LDA 1,X
 STA TCOLOR

XGCOLR
 PULS B
 PULS A,X,Y,U,PC

* exceptions for seasons
SEASON
 LDB ,S
 ANDB #$0F
 DECB
 LDA #4
 MUL
 LEAX SEACL,PCR
 LEAX D,X
 BRA GCCONT

* colors for seasons
SEACL
*spring
 FCB 13
 FCB $66 blue
 FCB 30
 FCB 0   black
*summer
 FCB 13
 FCB $88 orange
 FCB 30
 FCB 0   black
*autumn
 FCB 13
 FCB $33 tan
 FCB 30
 FCB 0   black
*winter
 FCB 13
 FCB 0   black
 FCB 30
 FCB 0   black

BRDRA
 LEAX ONEBAM,PCR
 BRA GCCONT
RDDRA
 LEAX -2,X
 BRA GCCONT
GRDRA
 LEAX -4,X
 BRA GCCONT

ONEBAM
 FCB 15
 FCB $44 green
 FCB 30
 FCB $33 brown

*green dragon
 FCB 30
 FCB $44 green

*red dragon
 FCB 30
 FCB $55 dark red

COTBL
*dragons
 FCB 30
 FCB 0 black
 FCB 0
 FCB 0
*winds
 FCB 30
 FCB $55 red
 FCB 0
 FCB 0
*seasons
 FCB 13
 FCB $44 green
 FCB 30
 FCB 0   black
*flowers
 FCB 13
 FCB $66 blue
 FCB 30
 FCB 0   black
*dots
 FCB 30
 FCB $22 purple
 FCB 0
 FCB 0
*craks
 FCB 5
 FCB $66 blue
 FCB 30
 FCB 0   black
*bams
 FCB 30
 FCB $33 brown
 FCB 0
 FCB 0

* get next tile mark color
NCOLOR
 PSHS D,X,Y,U
 DEC TCOLC
 BGT XNCOLR
 LDX TCOLP
 LEAX 2,X
 STX TCOLP
 LDA ,X
 STA TCOLC
 LDA 1,X
 STA TCOLOR
XNCOLR
 PULS D,X,Y,U,PC

CHIME
 PSHS D
 LDA $FF23
 PSHS A
 ORA #8
 STA $FF23
 LDA $FF01
 PSHS A
 ANDA #$F7
 STA $FF01
 LDA $FF03
 PSHS A
 ANDA #$F7
 STA $FF03

 CLRB
CHIS
 LEAX SINTBL,PCR
 LDA #32
 PSHS A
CHI0
 DEC ,S
 BLT XCHI0
 LDA ,X+
 PSHS B
 MUL
 LSLA
 LSLA
 ANDA #$FC
 STA $FF20
 PULS B
 BRA CHI0
XCHI0
 PULS A
 DECB
 BNE CHIS

 PULS A
 STA $FF03
 PULS A
 STA $FF01
 PULS A
 STA $FF23
 PULS D,PC

SINTBL
 FCB $20,$26,$2C,$31,$36,$3A,$3D,$3F
 FCB $3F,$3F,$3D,$3A,$36,$31,$2C,$26
 FCB $20,$19,$13,$0E,$09,$05,$02,$00
 FCB $00,$00,$02,$05,$09,$0E,$13,$19

MINIT
 LDX #$FFA0
 LDY #$FFA8
 LEAU MTBL,PCR
 LDA #8
 PSHS A
MINI0
 DEC ,S
 BLT XMINI
 LDD ,U++
 STA ,X+
 STB ,Y+
 BRA MINI0
XMINI
 PULS A
 RTS

MTBL
 FCB $38,$38 $FFA0 $FFA8
 FCB $39,$39
 FCB $3A,$3A
 FCB $3B,$3B
 FCB $30,$3C $FFA4
 FCB $31,$3D
 FCB $32,$3E
 FCB $33,$3F

**** Victory Dragon
VICTOR
 TST COUNT
 BNE XVIC
 
 LBSR CUROFF
 LBSR DELAY
 LDA #4
 LDB #5
 LBSR CPOS
 LEAU VTMP,PCR
 LBSR MSG
 LDU CURMNU
 LBSR DMENU
 LBSR CURON

XVIC
 RTS

VTMP
 FCC "Ye olde victory Dragon"
 FCC " goes here",0

* A nice long delay
DELAY
 LDX #0
A@
 MUL
 MUL
 MUL
 LEAX -1,X
 BNE A@
 RTS

* Challenge match scoreboard
CHBORD
 LBSR CLS
 LBSR BORDER

 LDA #5     "Challenge match results"
 LDB #6
 LBSR CPOS
 LEAU CHRES,PCR
 LBSR MSG

 LDA #7     "Player 1"
 LDB #8
 LBSR CPOS
 LEAU PLAYR1,PCR
 LBSR MSG

 LDA #21    Player 1 score
 LDB #8
 LBSR CPOS
 LDB SCORES
 LBSR PRTNUM

 LDA #7     "Player 2"
 LDB #10
 LBSR CPOS
 LEAU PLAYR2,PCR
 LBSR MSG

 LDA #21    Player 2 score
 LDB #10
 LBSR CPOS
 LDB SCORES+1
 LBSR PRTNUM

 LDA TMOUT
 CMPA #4
 BNE A@
 LDA #5     "Too many turns"
 LDB #13
 LBSR CPOS
 LEAU TIMOUT,PCR
 LBSR MSG
A@

 LDA #5     "This match is ended"
 LDB #19
 LBSR CPOS
 LEAU ENDED,PCR
 LBSR MSG

 LDA #5     "Press any key..."
 LDB #21
 LBSR CPOS
 LEAU PRESS,PCR
 LBSR MSG

*wait for key here
 BSR KWAIT
 RTS

CHRES
 FCC "Challenge match results:",0
PRESS
 FCC "Press any key to exit",0
TIMOUT
 FCC "Too many turns have passed",0
ENDED
 FCC "This match is ended",0

KWAIT
A@
 LBSR KCHEK  wait for no key
 BNE A@
B@
 LBSR KCHEK  wait for key
 BEQ B@
 RTS

* check for key pressed
KCHEK
 CLR $FF02
 LDA $FF00
 ANDA #$7F
 CMPA #$7F
 RTS

* Refresh game screen state
*
*  U -> tile table entry
*  B = tile position 1-144
*
REFRES
 PSHS D,X,Y
 CMPB #144 sneaky trick for tile 144
 BNE C@
 LDB #141
 LDU #140*7+TILES
C@
 PSHS U
 STB TLPOS
 LBSR CUROFF
 CLR MTIMER
 LBSR CLMSG
 LBSR TASK1 alter inactive screen
 LBSR CLSX

* redraw to the right
 LDU ,S
 LDA 4,U right
 BEQ N@
* based on tile to right
 LDB #7
 DECA
 MUL
 LDU #TILES
 LEAU D,U
 LDU 1,U voffset
 LEAU -RO,U
 BRA C@
N@
* no tile to immediate right
 LDU 1,U voffset
 LEAU -RO+CO,U
C@
 LBSR PILE3

* redraw column at active tile
 LDU ,S
 LDU 1,U
 LEAU -RO,U
 LBSR PILE3

* redraw to left
 LDU ,S
 LDA 3,U
 BEQ N@
* based on tile to left
 DECA
 LDU #TILES
 LDB #7
 MUL
 LEAU D,U
 LDU 1,U
 LEAU -RO,U
 BRA C@
* no tile to left
N@
 LDU 1,U
 LEAU -RO-CO,U
C@
 LBSR PILE3

* do tile 144 just in case
 LBSR DO144

* transfer region to active screen
 LDX ,S
 LDX 1,X voffset
 LDB TLPOS
 CMPB #12
 BLS X@
 LEAX -HFROW,X
X@
 LEAX -HFCOL,X
 TFR X,D
 LSRA
 RORB
 TFR D,X
 LBSR FUDGE
*now x points to UL corner of block
*20 bytes wide, 48 rows high
 LDA #36 assume tile 1-12 or 76-87
 LDB TLPOS
 CMPB #12 tile 1-12?
 BLS Q@ yes
* tile 13-144
 CMPB #75
 BLS R@ 13-75
* tile 76-144
 CMPB #87
 BLO Q@
R@
 LDA #48 not 1-12, 76-87
Q@
 PSHS A
A@
 DEC ,S
 BLT Z@
 TFR X,Y
 LBSR ONEROW
C@
 LEAX 160,X next row
 BRA A@
Z@
 PULS A
 CLRA
 CLRB
 LBSR TASK0 change to active screen
 LBSR CURON
 PULS U

 LBSR UCOUNT
 TST TLIMIT
 BEQ A@
 LBSR UTSCOR
 LBSR UUTIME
A@
 PULS D,X,Y,PC

PILE3
 PSHS U
 BSR VPILE
 LEAU RO,U
 BSR VPILE
 LEAU RO,U
 BSR VPILE
 PULS U
 RTS

* draw pile based on tile table pointer
*
* U -> tile table entry
*
TPILE
 PSHS D,X,Y,U
 BRA F@
*
* draw pile based on voffset
*
* U = voffset
*
VPILE
 PSHS D,X,Y,U
 TFR U,X
* look for base tile
 LDU #TILES
 LDA #87
A@
 CMPX 1,U
 BEQ F@
 LEAU 7,U
 DECA
 BNE A@
 PULS D,X,Y,U,PC no such base
* found base tile
* U points to it
F@
 LDX 1,U voffset of base tile
 CLR FACE id of top tile
* draw base and upper tiles
L@
 TST ,U tile exists?
 BLE N@ no
 LDB ,U exists
 STB FACE remember tile id
 STX FACE+1 and voffset
 STU FACE+3 and tile table pointer
 PSHS U
 LBSR EDGE do the edge
 PULS U
 LDA 5,U tile above it
 BEQ N@ isn't one
 CMPA #144 tile 144?
 BEQ N@ forget it
 DECA
 LDB #7
 MUL
 LDU #TILES
 LEAU D,U link to tile above
 LEAX -2*320+2,X voffset to next level
 BRA L@
* found the top of the pile
N@
 LDB FACE need to draw face?
 BEQ Z@ no
 LDX FACE+1 voffset
 LDU FACE+3 tile table pointer
 CMPU STILE1
 BEQ H@
 CMPU STILE2
 BNE W@
H@
 LEAU BLANKH,PCR highlight face tile
 BRA T@
W@
 LEAU BLANK,PCR de-highlighted tile
T@
 LBSR TILE draw blank tile
 LDX FACE+1
 LDU FACE+3
 LBSR SHADOW
 LDX FACE+1
 LDB FACE
 LBSR MKTILE mark tile
Z@
 PULS D,X,Y,U,PC

ONEROW
 LDA TLPOS
 CMPA #31
 BNE A@
 LEAY 4,Y
 BRA B@
A@
 LDU ,Y get from inactive
 LBSR TASK0 change to active
 STU ,Y++ put on active
 LBSR TASK1 change to inactive 
 LDU ,Y get from inactive
 LBSR TASK0 change to active
 STU ,Y++ put on active
 LBSR TASK1 change to inactive 
B@
 LDU ,Y get from inactive
 LBSR TASK0 change to active
 STU ,Y++ put on active
 LBSR TASK1 change to inactive 
 LDU ,Y get from inactive
 LBSR TASK0 change to active
 STU ,Y++ put on active
 LBSR TASK1 change to inactive 
 LDU ,Y get from inactive
 LBSR TASK0 change to active
 STU ,Y++ put on active
 LBSR TASK1 change to inactive 
 LDU ,Y get from inactive
 LBSR TASK0 change to active
 STU ,Y++ put on active
 LBSR TASK1 change to inactive 
 LDU ,Y get from inactive
 LBSR TASK0 change to active
 STU ,Y++ put on active
 LBSR TASK1 change to inactive 
 LDU ,Y get from inactive
 LBSR TASK0 change to active
 STU ,Y++ put on active
 LBSR TASK1 change to inactive 
 LDA TLPOS
 CMPA #45
 BEQ Z@
 LDU ,Y get from inactive
 LBSR TASK0 change to active
 STU ,Y++ put on active
 LBSR TASK1 change to inactive 
 LDU ,Y get from inactive
 LBSR TASK0 change to active
 STU ,Y++ put on active
 LBSR TASK1 change to inactive 
Z@
 RTS

* add 3D yellow edge highlighting
* at left and bottom of tile
*
* X = pixel offset
* B = tile id
*
EDGE
 PSHS B,X
 TFR X,D
 ANDB #1
 BEQ EVEDGE

*odd byte boundary
 TFR X,D
 LSRA
 RORB
 TFR D,X
 LBSR FUDGE
*detail at upper left corner
 LEAX -1,X
 LEAX 160,X
 LDA #$E1
 STA 1,X
 LEAX 160,X
 LDA ,X
 ANDA #$F0
 ORA #$0E
 STA ,X
 LDA #$11
 STA 1,X
 LEAX 160,X
*vertical highlight
 LDA #23
 PSHS A
L@
 DEC ,S
 BLT Z@
 LDA 1,X
 ANDA #$0F
 ORA #$10
 STA 1,X
 LDA ,X
 ANDA #$F0
 ORA #$01
 STA ,X
 LEAX 160,X
 BRA L@
Z@
 PULS A

*horizontal highlight
 LEAX -2*160,X
 LEAX 1,X
 LDA #10
 LDB #$11
A@
 DECA
 BLT Z@
 STB 160,X
 STB ,X+
 BRA A@
Z@
 
*detail at lower right corner
 LDA #$1E
 STA ,X
 LEAX 160,X
 LDA ,X
 ANDA #$0F
 ORA #$E0
 STA ,X
 BRA XEDGE

*even byte boundary
EVEDGE
 TFR X,D
 LSRA
 RORB
 TFR D,X
 LBSR FUDGE
 LDA #$11 yellow
*detail at upper left corner
 LEAX -1,X
 LEAX 160,X
 LDA ,X
 ANDA #$F0
 ORA #$0E
 STA ,X
 LEAX 160,X
 LDA #$E1
 STA ,X
*vertical highlight
 LEAX 160,X
 LDA #$11
 LDB #23
L@
 DECB
 BLT Z@
 STA ,X
 LEAX 160,X
 BRA L@
Z@

*horizontal highlight
 LEAX -2*160,X
 LDA #$11
 LDB #10
L@
 DECB
 BLT Z@
 STA 160,X
 STA ,X+
 BRA L@
Z@

*detail at lower right corner
 LDA #$1E
 STA ,X
 LEAX 160,X
 LDA ,X
 ANDA #$0F
 ORA #$E0
 STA ,X

XEDGE
 PULS B,X,PC

CLTILE
 CLR STILE1
 CLR STILE1+1
 CLR STILE1+2
 CLR STILE2
 CLR STILE2+1
 CLR STILE2+2
 RTS

DO144
 PSHS D,X,Y,U
 LDU #TILES
 LEAU 143*7,U
 LDB ,U
 BLE XDO144
 PSHS U

 LDX 1,U
 LEAX -2*320+2,X
 LEAX -2*320+2,X
 LEAX -2*320+2,X
 LEAX -2*320+2,X
 PSHS X
 LBSR EDGE
 LDU 2,S
 LBSR SHADOW

 LDU 2,S
 CMPU STILE1
 BEQ H@
 CMPU STILE2
 BEQ H@
 LEAU BLANK,PCR
 BRA C@
H@
 LEAU BLANKH,PCR
C@
 LBSR TILE

 PULS X
 LDU ,S
 LDB ,U
 LBSR MKTILE

 PULS U
XDO144
 PULS D,X,Y,U,PC

*check to see if tiles match
*
* U -> tile table entry
* Y -> other tile table entry
*
MATCH
 LDA ,U
 CMPA ,Y
 BEQ Y@
*check seasons/flowers match exception
 ANDA #$F0
 CMPA #$30
 BEQ SEACK
 CMPA #$40
 BNE N@
*check flower
 LDA ,Y
 ANDA #$F0
 CMPA #$40 other is flower?
 BEQ Y@
 BRA N@
*check season
SEACK
 LDA ,Y
 ANDA #$F0
 CMPA #$30 other is season?
 BNE N@
*tiles match
Y@
 CLRA
 TSTA
 RTS
N@
 LDA #1
 TSTA
 RTS

VSYNC
 TST $FF02
A@
 TST $FF03
 BGE A@
 RTS

* Draw shadow!!
*
* X = pixel offset
* U -> tile table entry
*
SHADOW
 PSHS X
 PSHS U
 LDA 4,U tile to right
 BEQ YSHAD never existed?
 DECA
 LDU #TILES
 LDB #7
 MUL
 LEAU D,U
 LDA ,U
 BGT XSHAD exists?

* need shadow
YSHAD
 LDU ,S
 LDD 2,S
 LSRA
 RORB
 TFR D,X
 LBSR FUDGE
 LDD 2,S
 ANDB #1
 BEQ EVSHAD

*odd byte shadow
 LEAX 11,X
 BSR SHADLN
 LDA #22
 PSHS A
A@
 DEC ,S
 BLT B@
 LEAX 160,X
 BSR SHADLN
 BSR SHADRN
 BRA A@
B@
 PULS B
 LEAX 160,X
 LBSR SHADLN
 BRA XSHAD

*even byte shadow
EVSHAD
 LEAX 10,X
 BSR SHADRN
 LDA #22
 PSHS A
A@
 DEC ,S
 BLT B@
 LEAX 160,X
 BSR SHADRN
 LEAX 1,X
 BSR SHADLN
 LEAX -1,X
 BRA A@
B@
 PULS B
 LEAX 160,X
 BSR SHADRN
 BRA XSHAD
 
XSHAD
 PULS U
 PULS X
 RTS

*shadow left nibble
*
* X -> byte
*
SHADLN
 PSHS U
 LDB ,X
 TFR B,A
 ANDA #$0F 
 ANDB #$F0
 LSRB
 LSRB
 LSRB
 LSRB
 LEAU DARKER,PCR
 LDB B,U
 LSLB
 LSLB
 LSLB
 LSLB
 PSHS A
 ORB ,S+
 STB ,X
 PULS U,PC

*shadow right nibble
*
* X -> byte
*
SHADRN
 PSHS U
 LDB ,X
 TFR B,A
 ANDA #$F0
 ANDB #$0F
 LEAU DARKER,PCR
 LDB B,U
 PSHS A
 ORB ,S+
 STB ,X
 PULS U,PC

DARKER
 FCB $0 0:black
 FCB $E 1:yellow
 FCB $0 2:dk purp
 FCB $3 3:pump orange
 FCB $0 4:dk green
 FCB $3 5:dk red
 FCB $7 6:blue
 FCB $0 7:dk blue
 FCB $3 8:lt orange
 FCB $9 9:background
 FCB $A A:unused
 FCB $0 B:grey
 FCB $E C:lt yel
 FCB $D D:flash
 FCB $0 E:grey
 FCB $E F:white

PING
 BSR  SNDON GET SOUND FROM 6 BIT DAC
 PSHS CC    SAVE IRQ FLAGS
 ORCC #$50  TURN OFF IRQS
 LDA #230   HOW LONG TO DO SOUND
A@
 BSR  B@    DO A TIME DELAY
*
 TFR  A,B   GET TIME COUNT
 ANDB #$F7  USE ONLY THE TOP 5 BITS
 ORB  #2    SET PRINTER BIT HIGH
 STB  $FF20 SEND IT OUT THE DAC PORT
*
 BSR  B@    DO A TIME DELAY
 LDB  #2    CLEAR ALL BITS BUT PRINTER
 STB  $FF20 ON DAC PORT
 DECA       MAKE BELL SOUND SMALLER
 DECA       BY 2
 CMPA #18   IS BELL DONE?
 BHS  A@    NO, THEN LOOP
 PULS CC    TURN ON IRQS
*
B@
 LDB #180   TIME DELAY USED BY PING
C@
 DECB
 BNE C@
 RTS

* MAKE A CLICK SOUND
CLIK
 LDA $FF20
 ANDA #3
 STA $FF20
 BSR SNDON   TURN SOUND ON TO DAC
 LDA  #10     START TIME DELAY SHORT
A@
 TFR  A,B     DO A DELAY (USE COUNT)
B@
 DECB         GET LONGER EACH TIME
 BNE  B@
 LDB  $FF20   GET DAC PORT
 EORB #$F0    FLIP TOP 4 BITS
 STB  $FF20   SAVE SET PORT
 INCA         MAKE DELAY LONGER
 CMPA #76     ALL DONE?
 BLO  A@      NO, LOOP BACK

SNDOFF
 LDA  $FF23  TURN OFF DAC SOUND
 ANDA #$F7   BY RESETTING THE BIT
 STA  $FF23
 CLRB        MAKE RETURN ZERO
 RTS         AND RETURN

SNDON
 LDA  $FF23  TURN ON THE SOUND BY
 ORA  #8     SETTING THE SOUND ON BIT
 STA  $FF23
 LDA  $FF01  GET LSB OF JOY/AUDIO
 ANDA #$FF-8 PORT AND RESET IT
 STA  $FF01  AND PUT IT BACK
 LDA  $FF03  GET MSB OF JOY/AUDIO
 ANDA #$FF-8 PORT AND RESET IT TOO
 STA  $FF03  AND PUT IT BACK
 RTS         NOW EXIT

TASK0
 CLRA
 STA FF91
 STA $FF91
 RTS

TASK1
 LDA #1
 STA FF91
 STA $FF91
 RTS

 INCL TABLE
 INCL DRAGONS
 INCL FONT
 INCL TILES
 INCL MENUS
 INCL TOURNEY

ZPROG

 END START
