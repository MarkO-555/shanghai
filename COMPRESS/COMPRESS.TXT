
 ORG $3000
DPTR  RMB 2 current data pointer
COUNT RMB 1 length of token
BCOUNT RMB 1 bytes represented by token
TOKEN RMB 4 token generated

*entry point
START
*turn off interrupts
 PSHS CC
 ORCC #$50

*set my own memory map
 LEAU MYMEM,PCR
 LBSR MINIT

*make token
 LBSR MAKTOK

*bump to next token
 LDX DPTR
 CLRA
 LDB BCOUNT
 LEAX D,X
 STX DPTR

*restore BASIC's memory map
 LEAU BASMEM,PCR
 LBSR MINIT

*return to BASIC
 PULS CC,PC

PPTR  RMB 2

TABLE
 FCB 0,1,2,3,4,5,6,8,9
 FCB 10,16,17,18,22,24,25,33,34,36
 FCB 38,48,49,50,51,54,57,64,68,69
 FCB 70,73,74,82,85,86,89,96,99,100
 FCB 101,102,104,105,106,116,128,132
 FCB 133,134,136,137,138,144,145,146
 FCB 147,148,149,150,152,153,154,160
 FCB 161,164,168,169,170

MAKTOK
 CLR TOKEN
 CLR TOKEN+1
 CLR TOKEN+2
 CLR TOKEN+3
 LBSR MAKRTK
*take repeat token
 LDD RTK
 STD TOKEN
 LDA RCOUNT
 STA BCOUNT

EXIT
 RTS

RTK RMB 2

*make repeat token
*
MAKRTK
 LBSR CVERT
 STA RTK
 CLR RCOUNT
 LDX DPTR
 LDA ,X
 LEAX 1,X
A@
 INC RCOUNT
 CMPA ,X+
 BEQ A@
*now we know how many
 LDA RCOUNT
 CMPA #1
 BLS ONEBYT
*two-byte token
 CLR COUNT
 INC COUNT
 INC COUNT
 LDA RCOUNT
 STA RTK+1
 LDB RCOUNT
 RTS
*one-byte token
ONEBYT
 CLR COUNT
 INC COUNT
 LDA #$80
 ORA RTK
 STA RTK
 LDB RCOUNT
 RTS

RCOUNT RMB 1

PTK RMB 4

CVERT
*get value
 LDX DPTR
 LDA ,X
*convert value to value table index
 LDB #$FF
 LEAU TABLE,PCR
A@
 INCB
 CMPA ,U+
 BNE A@
 TFR B,A
 RTS

*initialize MMU registers
MINIT
 LDX #$FFA0
 LDA #16
 PSHS A
A@
 DEC ,S
 BLT Z@
 LDA ,U+
 STA ,X+
 BRA A@
Z@
 PULS A,PC

MAXLEN RMB 1

BASMEM
 FCB $38,$39,$3A,$3B,$3C,$3D,$3E,$3F
 FCB $38,$30,$31,$32,$33,$3D,$35,$3F
MYMEM
 FCB $38,$39,$3A,$3B,$30,$31,$32,$33
 FCB $38,$39,$3A,$3B,$30,$31,$32,$33

